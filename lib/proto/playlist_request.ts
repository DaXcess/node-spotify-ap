// @generated by protobuf-ts 2.0.6
// @generated from protobuf file "playlist_request.proto" (package "spotify", syntax proto2)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message spotify.FormatListAttribute
 */
export interface FormatListAttribute {
    /**
     * @generated from protobuf field: optional string key = 1;
     */
    key?: string;
    /**
     * @generated from protobuf field: optional string value = 2;
     */
    value?: string;
}
/**
 * @generated from protobuf message spotify.Allows
 */
export interface Allows {
    /**
     * @generated from protobuf field: optional bool can_insert = 1;
     */
    canInsert?: boolean;
    /**
     * @generated from protobuf field: optional bool can_remove = 2;
     */
    canRemove?: boolean;
}
/**
 * @generated from protobuf message spotify.PlaylistMetadata
 */
export interface PlaylistMetadata {
    /**
     * @generated from protobuf field: optional string link = 1;
     */
    link?: string;
    /**
     * @generated from protobuf field: optional string name = 2;
     */
    name?: string;
    /**
     * @generated from protobuf field: optional spotify.User owner = 3;
     */
    owner?: User;
    /**
     * @generated from protobuf field: optional bool owned_by_self = 4;
     */
    ownedBySelf?: boolean;
    /**
     * @generated from protobuf field: optional bool collaborative = 5;
     */
    collaborative?: boolean;
    /**
     * @generated from protobuf field: optional uint32 total_length = 6;
     */
    totalLength?: number;
    /**
     * @generated from protobuf field: optional string description = 7;
     */
    description?: string;
    /**
     * @generated from protobuf field: optional spotify.ImageGroup pictures = 8;
     */
    pictures?: ImageGroup;
    /**
     * @generated from protobuf field: optional bool followed = 9;
     */
    followed?: boolean;
    /**
     * @generated from protobuf field: optional bool published = 10;
     */
    published?: boolean;
    /**
     * @generated from protobuf field: optional bool browsable_offline = 11;
     */
    browsableOffline?: boolean;
    /**
     * @generated from protobuf field: optional bool description_from_annotate = 12;
     */
    descriptionFromAnnotate?: boolean;
    /**
     * @generated from protobuf field: optional bool picture_from_annotate = 13;
     */
    pictureFromAnnotate?: boolean;
    /**
     * @generated from protobuf field: optional string format_list_type = 14;
     */
    formatListType?: string;
    /**
     * @generated from protobuf field: repeated spotify.FormatListAttribute format_list_attributes = 15;
     */
    formatListAttributes: FormatListAttribute[];
    /**
     * @generated from protobuf field: optional bool can_report_annotation_abuse = 16;
     */
    canReportAnnotationAbuse?: boolean;
    /**
     * @generated from protobuf field: optional bool is_loaded = 17;
     */
    isLoaded?: boolean;
    /**
     * @generated from protobuf field: optional spotify.Allows allows = 18;
     */
    allows?: Allows;
    /**
     * @generated from protobuf field: optional string load_state = 19;
     */
    loadState?: string;
    /**
     * @generated from protobuf field: optional spotify.User made_for = 20;
     */
    madeFor?: User;
}
/**
 * @generated from protobuf message spotify.PlaylistOfflineState
 */
export interface PlaylistOfflineState {
    /**
     * @generated from protobuf field: optional string offline = 1;
     */
    offline?: string;
    /**
     * @generated from protobuf field: optional uint32 sync_progress = 2;
     */
    syncProgress?: number;
}
/**
 * @generated from protobuf message spotify.TrackCollectionState
 */
export interface TrackCollectionState {
    /**
     * @generated from protobuf field: optional bool is_in_collection = 1;
     */
    isInCollection?: boolean;
    /**
     * @generated from protobuf field: optional bool can_add_to_collection = 2;
     */
    canAddToCollection?: boolean;
    /**
     * @generated from protobuf field: optional bool is_banned = 3;
     */
    isBanned?: boolean;
    /**
     * @generated from protobuf field: optional bool can_ban = 4;
     */
    canBan?: boolean;
}
/**
 * @generated from protobuf message spotify.TrackOfflineState
 */
export interface TrackOfflineState {
    /**
     * @generated from protobuf field: optional string offline = 1;
     */
    offline?: string;
}
/**
 * @generated from protobuf message spotify.TrackPlayState
 */
export interface TrackPlayState {
    /**
     * @generated from protobuf field: optional bool is_playable = 1;
     */
    isPlayable?: boolean;
}
/**
 * @generated from protobuf message spotify.EpisodeShowMetadata
 */
export interface EpisodeShowMetadata {
    /**
     * @generated from protobuf field: optional string link = 1;
     */
    link?: string;
    /**
     * @generated from protobuf field: optional string name = 2;
     */
    name?: string;
    /**
     * @generated from protobuf field: optional string publisher = 3;
     */
    publisher?: string;
    /**
     * @generated from protobuf field: optional spotify.ImageGroup covers = 4;
     */
    covers?: ImageGroup;
}
/**
 * @generated from protobuf message spotify.EpisodeMetadata
 */
export interface EpisodeMetadata {
    /**
     * @generated from protobuf field: optional spotify.EpisodeShowMetadata show = 1;
     */
    show?: EpisodeShowMetadata;
    /**
     * @generated from protobuf field: optional string link = 2;
     */
    link?: string;
    /**
     * @generated from protobuf field: optional string name = 3;
     */
    name?: string;
    /**
     * @generated from protobuf field: optional uint32 length = 4;
     */
    length?: number;
    /**
     * @generated from protobuf field: optional spotify.ImageGroup covers = 5;
     */
    covers?: ImageGroup;
    /**
     * @generated from protobuf field: optional string manifest_id = 6;
     */
    manifestId?: string;
    /**
     * @generated from protobuf field: optional string description = 7;
     */
    description?: string;
    /**
     * @generated from protobuf field: optional int64 publish_date = 8;
     */
    publishDate?: bigint;
    /**
     * @generated from protobuf field: optional spotify.ImageGroup freeze_frames = 9;
     */
    freezeFrames?: ImageGroup;
    /**
     * @generated from protobuf field: optional string language = 10;
     */
    language?: string;
    /**
     * @generated from protobuf field: optional bool available = 11;
     */
    available?: boolean;
    /**
     * @generated from protobuf field: optional int32 media_type_enum = 12;
     */
    mediaTypeEnum?: number;
    /**
     * @generated from protobuf field: optional int32 number = 13;
     */
    number?: number;
    /**
     * @generated from protobuf field: optional bool backgroundable = 14;
     */
    backgroundable?: boolean;
    /**
     * @generated from protobuf field: optional string preview_manifest_id = 15;
     */
    previewManifestId?: string;
    /**
     * @generated from protobuf field: optional bool is_explicit = 16;
     */
    isExplicit?: boolean;
}
/**
 * @generated from protobuf message spotify.EpisodeSyncState
 */
export interface EpisodeSyncState {
    /**
     * @generated from protobuf field: optional string offline_state = 1;
     */
    offlineState?: string;
    /**
     * @generated from protobuf field: optional uint32 sync_progress = 2;
     */
    syncProgress?: number;
}
/**
 * @generated from protobuf message spotify.EpisodePlayState
 */
export interface EpisodePlayState {
    /**
     * @generated from protobuf field: optional uint32 time_left = 1;
     */
    timeLeft?: number;
    /**
     * @generated from protobuf field: optional bool is_playable = 2;
     */
    isPlayable?: boolean;
    /**
     * @generated from protobuf field: optional bool is_played = 3;
     */
    isPlayed?: boolean;
    /**
     * @generated from protobuf field: optional uint32 last_played_at = 4;
     */
    lastPlayedAt?: number;
}
/**
 * @generated from protobuf message spotify.EpisodeCollectionState
 */
export interface EpisodeCollectionState {
    /**
     * @generated from protobuf field: optional bool is_in_collection = 1;
     */
    isInCollection?: boolean;
    /**
     * @generated from protobuf field: optional bool is_new = 2;
     */
    isNew?: boolean;
    /**
     * @generated from protobuf field: optional bool is_in_listen_later = 3;
     */
    isInListenLater?: boolean;
}
/**
 * @generated from protobuf message spotify.TrackAlbumArtistMetadata
 */
export interface TrackAlbumArtistMetadata {
    /**
     * @generated from protobuf field: optional string link = 1;
     */
    link?: string;
    /**
     * @generated from protobuf field: optional string name = 2;
     */
    name?: string;
}
/**
 * @generated from protobuf message spotify.TrackAlbumMetadata
 */
export interface TrackAlbumMetadata {
    /**
     * @generated from protobuf field: optional spotify.TrackAlbumArtistMetadata artist = 1;
     */
    artist?: TrackAlbumArtistMetadata;
    /**
     * @generated from protobuf field: optional string link = 2;
     */
    link?: string;
    /**
     * @generated from protobuf field: optional string name = 3;
     */
    name?: string;
    /**
     * @generated from protobuf field: optional spotify.ImageGroup covers = 4;
     */
    covers?: ImageGroup;
}
/**
 * @generated from protobuf message spotify.TrackArtistMetadata
 */
export interface TrackArtistMetadata {
    /**
     * @generated from protobuf field: optional string link = 1;
     */
    link?: string;
    /**
     * @generated from protobuf field: optional string name = 2;
     */
    name?: string;
}
/**
 * @generated from protobuf message spotify.TrackMetadata
 */
export interface TrackMetadata {
    /**
     * @generated from protobuf field: optional spotify.TrackAlbumMetadata album = 1;
     */
    album?: TrackAlbumMetadata;
    /**
     * @generated from protobuf field: repeated spotify.TrackArtistMetadata artist = 2;
     */
    artist: TrackArtistMetadata[];
    /**
     * @generated from protobuf field: optional string link = 3;
     */
    link?: string;
    /**
     * @generated from protobuf field: optional string name = 4;
     */
    name?: string;
    /**
     * @generated from protobuf field: optional uint32 length = 5;
     */
    length?: number;
    /**
     * @generated from protobuf field: optional bool playable = 6;
     */
    playable?: boolean;
    /**
     * @generated from protobuf field: optional uint32 disc_number = 7;
     */
    discNumber?: number;
    /**
     * @generated from protobuf field: optional uint32 track_number = 8;
     */
    trackNumber?: number;
    /**
     * @generated from protobuf field: optional bool is_explicit = 9;
     */
    isExplicit?: boolean;
    /**
     * @generated from protobuf field: optional string preview_id = 10;
     */
    previewId?: string;
    /**
     * @generated from protobuf field: optional bool is_local = 11;
     */
    isLocal?: boolean;
    /**
     * @generated from protobuf field: optional bool playable_local_track = 12;
     */
    playableLocalTrack?: boolean;
    /**
     * @generated from protobuf field: optional bool has_lyrics = 13;
     */
    hasLyrics?: boolean;
    /**
     * @generated from protobuf field: optional bool is_premium_only = 14;
     */
    isPremiumOnly?: boolean;
    /**
     * @generated from protobuf field: optional bool locally_playable = 15;
     */
    locallyPlayable?: boolean;
    /**
     * @generated from protobuf field: optional string playable_track_link = 16;
     */
    playableTrackLink?: string;
    /**
     * @generated from protobuf field: optional uint32 popularity = 17;
     */
    popularity?: number;
}
/**
 * @generated from protobuf message spotify.ImageGroup
 */
export interface ImageGroup {
    /**
     * @generated from protobuf field: optional string standard_link = 1;
     */
    standardLink?: string;
    /**
     * @generated from protobuf field: optional string small_link = 2;
     */
    smallLink?: string;
    /**
     * @generated from protobuf field: optional string large_link = 3;
     */
    largeLink?: string;
    /**
     * @generated from protobuf field: optional string xlarge_link = 4;
     */
    xlargeLink?: string;
}
/**
 * @generated from protobuf message spotify.User
 */
export interface User {
    /**
     * @generated from protobuf field: optional string link = 1;
     */
    link?: string;
    /**
     * @generated from protobuf field: optional string username = 2;
     */
    username?: string;
    /**
     * @generated from protobuf field: optional string display_name = 3;
     */
    displayName?: string;
    /**
     * @generated from protobuf field: optional string image_uri = 4;
     */
    imageUri?: string;
    /**
     * @generated from protobuf field: optional string thumbnail_uri = 5;
     */
    thumbnailUri?: string;
}
/**
 * @generated from protobuf message spotify.Item
 */
export interface Item {
    /**
     * @generated from protobuf field: optional string header_field = 1;
     */
    headerField?: string;
    /**
     * @generated from protobuf field: optional uint32 add_time = 2;
     */
    addTime?: number;
    /**
     * @generated from protobuf field: optional spotify.User added_by = 3;
     */
    addedBy?: User;
    /**
     * @generated from protobuf field: optional spotify.TrackMetadata track_metadata = 4;
     */
    trackMetadata?: TrackMetadata;
    /**
     * @generated from protobuf field: optional spotify.TrackCollectionState track_collection_state = 5;
     */
    trackCollectionState?: TrackCollectionState;
    /**
     * @generated from protobuf field: optional spotify.TrackOfflineState track_offline_state = 6;
     */
    trackOfflineState?: TrackOfflineState;
    /**
     * @generated from protobuf field: optional string row_id = 7;
     */
    rowId?: string;
    /**
     * @generated from protobuf field: optional spotify.TrackPlayState track_play_state = 8;
     */
    trackPlayState?: TrackPlayState;
    /**
     * @generated from protobuf field: repeated spotify.FormatListAttribute format_list_attributes = 9;
     */
    formatListAttributes: FormatListAttribute[];
    /**
     * @generated from protobuf field: optional spotify.EpisodeMetadata episode_metadata = 10;
     */
    episodeMetadata?: EpisodeMetadata;
    /**
     * @generated from protobuf field: optional spotify.EpisodeSyncState episode_offline_state = 11;
     */
    episodeOfflineState?: EpisodeSyncState;
    /**
     * @generated from protobuf field: optional spotify.EpisodeCollectionState episode_collection_state = 12;
     */
    episodeCollectionState?: EpisodeCollectionState;
    /**
     * @generated from protobuf field: optional spotify.EpisodePlayState episode_play_state = 13;
     */
    episodePlayState?: EpisodePlayState;
    /**
     * @generated from protobuf field: optional spotify.ImageGroup display_covers = 14;
     */
    displayCovers?: ImageGroup;
}
/**
 * @generated from protobuf message spotify.Playlist
 */
export interface Playlist {
    /**
     * @generated from protobuf field: optional spotify.PlaylistMetadata playlist_metadata = 1;
     */
    playlistMetadata?: PlaylistMetadata;
    /**
     * @generated from protobuf field: optional spotify.PlaylistOfflineState playlist_offline_state = 2;
     */
    playlistOfflineState?: PlaylistOfflineState;
}
/**
 * @generated from protobuf message spotify.RecommendationItem
 */
export interface RecommendationItem {
    /**
     * @generated from protobuf field: optional spotify.TrackMetadata track_metadata = 1;
     */
    trackMetadata?: TrackMetadata;
    /**
     * @generated from protobuf field: optional spotify.TrackCollectionState track_collection_state = 2;
     */
    trackCollectionState?: TrackCollectionState;
}
/**
 * @generated from protobuf message spotify.Response
 */
export interface Response {
    /**
     * @generated from protobuf field: repeated spotify.Item item = 1;
     */
    item: Item[];
    /**
     * @generated from protobuf field: optional spotify.Playlist playlist = 2;
     */
    playlist?: Playlist;
    /**
     * @generated from protobuf field: optional uint32 unfiltered_length = 3;
     */
    unfilteredLength?: number;
    /**
     * @generated from protobuf field: optional uint32 unranged_length = 4;
     */
    unrangedLength?: number;
    /**
     * @generated from protobuf field: optional uint64 duration = 5;
     */
    duration?: bigint;
    /**
     * @generated from protobuf field: optional bool loading_contents = 6;
     */
    loadingContents?: boolean;
    /**
     * @generated from protobuf field: optional uint64 last_modification = 7;
     */
    lastModification?: bigint;
    /**
     * @generated from protobuf field: optional uint32 num_followers = 8;
     */
    numFollowers?: number;
    /**
     * @generated from protobuf field: optional bool playable = 9;
     */
    playable?: boolean;
    /**
     * @generated from protobuf field: repeated spotify.RecommendationItem recommendations = 10;
     */
    recommendations: RecommendationItem[];
    /**
     * @generated from protobuf field: optional bool has_explicit_content = 11;
     */
    hasExplicitContent?: boolean;
    /**
     * @generated from protobuf field: optional bool contains_spotify_tracks = 12;
     */
    containsSpotifyTracks?: boolean;
    /**
     * @generated from protobuf field: optional bool contains_episodes = 13;
     */
    containsEpisodes?: boolean;
}
// @generated message type with reflection information, may provide speed optimized methods
class FormatListAttribute$Type extends MessageType<FormatListAttribute> {
    constructor() {
        super("spotify.FormatListAttribute", [
            { no: 1, name: "key", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FormatListAttribute>): FormatListAttribute {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FormatListAttribute>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FormatListAttribute): FormatListAttribute {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string key */ 1:
                    message.key = reader.string();
                    break;
                case /* optional string value */ 2:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FormatListAttribute, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string key = 1; */
        if (message.key !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.key);
        /* optional string value = 2; */
        if (message.value !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spotify.FormatListAttribute
 */
export const FormatListAttribute = new FormatListAttribute$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Allows$Type extends MessageType<Allows> {
    constructor() {
        super("spotify.Allows", [
            { no: 1, name: "can_insert", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "can_remove", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Allows>): Allows {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Allows>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Allows): Allows {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool can_insert */ 1:
                    message.canInsert = reader.bool();
                    break;
                case /* optional bool can_remove */ 2:
                    message.canRemove = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Allows, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool can_insert = 1; */
        if (message.canInsert !== undefined)
            writer.tag(1, WireType.Varint).bool(message.canInsert);
        /* optional bool can_remove = 2; */
        if (message.canRemove !== undefined)
            writer.tag(2, WireType.Varint).bool(message.canRemove);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spotify.Allows
 */
export const Allows = new Allows$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlaylistMetadata$Type extends MessageType<PlaylistMetadata> {
    constructor() {
        super("spotify.PlaylistMetadata", [
            { no: 1, name: "link", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "owner", kind: "message", T: () => User },
            { no: 4, name: "owned_by_self", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "collaborative", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "total_length", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "description", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "pictures", kind: "message", T: () => ImageGroup },
            { no: 9, name: "followed", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "published", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "browsable_offline", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "description_from_annotate", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "picture_from_annotate", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "format_list_type", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "format_list_attributes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FormatListAttribute },
            { no: 16, name: "can_report_annotation_abuse", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "is_loaded", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 18, name: "allows", kind: "message", T: () => Allows },
            { no: 19, name: "load_state", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 20, name: "made_for", kind: "message", T: () => User }
        ]);
    }
    create(value?: PartialMessage<PlaylistMetadata>): PlaylistMetadata {
        const message = { formatListAttributes: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlaylistMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlaylistMetadata): PlaylistMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string link */ 1:
                    message.link = reader.string();
                    break;
                case /* optional string name */ 2:
                    message.name = reader.string();
                    break;
                case /* optional spotify.User owner */ 3:
                    message.owner = User.internalBinaryRead(reader, reader.uint32(), options, message.owner);
                    break;
                case /* optional bool owned_by_self */ 4:
                    message.ownedBySelf = reader.bool();
                    break;
                case /* optional bool collaborative */ 5:
                    message.collaborative = reader.bool();
                    break;
                case /* optional uint32 total_length */ 6:
                    message.totalLength = reader.uint32();
                    break;
                case /* optional string description */ 7:
                    message.description = reader.string();
                    break;
                case /* optional spotify.ImageGroup pictures */ 8:
                    message.pictures = ImageGroup.internalBinaryRead(reader, reader.uint32(), options, message.pictures);
                    break;
                case /* optional bool followed */ 9:
                    message.followed = reader.bool();
                    break;
                case /* optional bool published */ 10:
                    message.published = reader.bool();
                    break;
                case /* optional bool browsable_offline */ 11:
                    message.browsableOffline = reader.bool();
                    break;
                case /* optional bool description_from_annotate */ 12:
                    message.descriptionFromAnnotate = reader.bool();
                    break;
                case /* optional bool picture_from_annotate */ 13:
                    message.pictureFromAnnotate = reader.bool();
                    break;
                case /* optional string format_list_type */ 14:
                    message.formatListType = reader.string();
                    break;
                case /* repeated spotify.FormatListAttribute format_list_attributes */ 15:
                    message.formatListAttributes.push(FormatListAttribute.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool can_report_annotation_abuse */ 16:
                    message.canReportAnnotationAbuse = reader.bool();
                    break;
                case /* optional bool is_loaded */ 17:
                    message.isLoaded = reader.bool();
                    break;
                case /* optional spotify.Allows allows */ 18:
                    message.allows = Allows.internalBinaryRead(reader, reader.uint32(), options, message.allows);
                    break;
                case /* optional string load_state */ 19:
                    message.loadState = reader.string();
                    break;
                case /* optional spotify.User made_for */ 20:
                    message.madeFor = User.internalBinaryRead(reader, reader.uint32(), options, message.madeFor);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlaylistMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string link = 1; */
        if (message.link !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.link);
        /* optional string name = 2; */
        if (message.name !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* optional spotify.User owner = 3; */
        if (message.owner)
            User.internalBinaryWrite(message.owner, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional bool owned_by_self = 4; */
        if (message.ownedBySelf !== undefined)
            writer.tag(4, WireType.Varint).bool(message.ownedBySelf);
        /* optional bool collaborative = 5; */
        if (message.collaborative !== undefined)
            writer.tag(5, WireType.Varint).bool(message.collaborative);
        /* optional uint32 total_length = 6; */
        if (message.totalLength !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.totalLength);
        /* optional string description = 7; */
        if (message.description !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.description);
        /* optional spotify.ImageGroup pictures = 8; */
        if (message.pictures)
            ImageGroup.internalBinaryWrite(message.pictures, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* optional bool followed = 9; */
        if (message.followed !== undefined)
            writer.tag(9, WireType.Varint).bool(message.followed);
        /* optional bool published = 10; */
        if (message.published !== undefined)
            writer.tag(10, WireType.Varint).bool(message.published);
        /* optional bool browsable_offline = 11; */
        if (message.browsableOffline !== undefined)
            writer.tag(11, WireType.Varint).bool(message.browsableOffline);
        /* optional bool description_from_annotate = 12; */
        if (message.descriptionFromAnnotate !== undefined)
            writer.tag(12, WireType.Varint).bool(message.descriptionFromAnnotate);
        /* optional bool picture_from_annotate = 13; */
        if (message.pictureFromAnnotate !== undefined)
            writer.tag(13, WireType.Varint).bool(message.pictureFromAnnotate);
        /* optional string format_list_type = 14; */
        if (message.formatListType !== undefined)
            writer.tag(14, WireType.LengthDelimited).string(message.formatListType);
        /* repeated spotify.FormatListAttribute format_list_attributes = 15; */
        for (let i = 0; i < message.formatListAttributes.length; i++)
            FormatListAttribute.internalBinaryWrite(message.formatListAttributes[i], writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* optional bool can_report_annotation_abuse = 16; */
        if (message.canReportAnnotationAbuse !== undefined)
            writer.tag(16, WireType.Varint).bool(message.canReportAnnotationAbuse);
        /* optional bool is_loaded = 17; */
        if (message.isLoaded !== undefined)
            writer.tag(17, WireType.Varint).bool(message.isLoaded);
        /* optional spotify.Allows allows = 18; */
        if (message.allows)
            Allows.internalBinaryWrite(message.allows, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* optional string load_state = 19; */
        if (message.loadState !== undefined)
            writer.tag(19, WireType.LengthDelimited).string(message.loadState);
        /* optional spotify.User made_for = 20; */
        if (message.madeFor)
            User.internalBinaryWrite(message.madeFor, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spotify.PlaylistMetadata
 */
export const PlaylistMetadata = new PlaylistMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlaylistOfflineState$Type extends MessageType<PlaylistOfflineState> {
    constructor() {
        super("spotify.PlaylistOfflineState", [
            { no: 1, name: "offline", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "sync_progress", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<PlaylistOfflineState>): PlaylistOfflineState {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlaylistOfflineState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlaylistOfflineState): PlaylistOfflineState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string offline */ 1:
                    message.offline = reader.string();
                    break;
                case /* optional uint32 sync_progress */ 2:
                    message.syncProgress = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlaylistOfflineState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string offline = 1; */
        if (message.offline !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.offline);
        /* optional uint32 sync_progress = 2; */
        if (message.syncProgress !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.syncProgress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spotify.PlaylistOfflineState
 */
export const PlaylistOfflineState = new PlaylistOfflineState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrackCollectionState$Type extends MessageType<TrackCollectionState> {
    constructor() {
        super("spotify.TrackCollectionState", [
            { no: 1, name: "is_in_collection", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "can_add_to_collection", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "is_banned", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "can_ban", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<TrackCollectionState>): TrackCollectionState {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TrackCollectionState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrackCollectionState): TrackCollectionState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool is_in_collection */ 1:
                    message.isInCollection = reader.bool();
                    break;
                case /* optional bool can_add_to_collection */ 2:
                    message.canAddToCollection = reader.bool();
                    break;
                case /* optional bool is_banned */ 3:
                    message.isBanned = reader.bool();
                    break;
                case /* optional bool can_ban */ 4:
                    message.canBan = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrackCollectionState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool is_in_collection = 1; */
        if (message.isInCollection !== undefined)
            writer.tag(1, WireType.Varint).bool(message.isInCollection);
        /* optional bool can_add_to_collection = 2; */
        if (message.canAddToCollection !== undefined)
            writer.tag(2, WireType.Varint).bool(message.canAddToCollection);
        /* optional bool is_banned = 3; */
        if (message.isBanned !== undefined)
            writer.tag(3, WireType.Varint).bool(message.isBanned);
        /* optional bool can_ban = 4; */
        if (message.canBan !== undefined)
            writer.tag(4, WireType.Varint).bool(message.canBan);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spotify.TrackCollectionState
 */
export const TrackCollectionState = new TrackCollectionState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrackOfflineState$Type extends MessageType<TrackOfflineState> {
    constructor() {
        super("spotify.TrackOfflineState", [
            { no: 1, name: "offline", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TrackOfflineState>): TrackOfflineState {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TrackOfflineState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrackOfflineState): TrackOfflineState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string offline */ 1:
                    message.offline = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrackOfflineState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string offline = 1; */
        if (message.offline !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.offline);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spotify.TrackOfflineState
 */
export const TrackOfflineState = new TrackOfflineState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrackPlayState$Type extends MessageType<TrackPlayState> {
    constructor() {
        super("spotify.TrackPlayState", [
            { no: 1, name: "is_playable", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<TrackPlayState>): TrackPlayState {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TrackPlayState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrackPlayState): TrackPlayState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool is_playable */ 1:
                    message.isPlayable = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrackPlayState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool is_playable = 1; */
        if (message.isPlayable !== undefined)
            writer.tag(1, WireType.Varint).bool(message.isPlayable);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spotify.TrackPlayState
 */
export const TrackPlayState = new TrackPlayState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EpisodeShowMetadata$Type extends MessageType<EpisodeShowMetadata> {
    constructor() {
        super("spotify.EpisodeShowMetadata", [
            { no: 1, name: "link", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "publisher", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "covers", kind: "message", T: () => ImageGroup }
        ]);
    }
    create(value?: PartialMessage<EpisodeShowMetadata>): EpisodeShowMetadata {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EpisodeShowMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EpisodeShowMetadata): EpisodeShowMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string link */ 1:
                    message.link = reader.string();
                    break;
                case /* optional string name */ 2:
                    message.name = reader.string();
                    break;
                case /* optional string publisher */ 3:
                    message.publisher = reader.string();
                    break;
                case /* optional spotify.ImageGroup covers */ 4:
                    message.covers = ImageGroup.internalBinaryRead(reader, reader.uint32(), options, message.covers);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EpisodeShowMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string link = 1; */
        if (message.link !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.link);
        /* optional string name = 2; */
        if (message.name !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* optional string publisher = 3; */
        if (message.publisher !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.publisher);
        /* optional spotify.ImageGroup covers = 4; */
        if (message.covers)
            ImageGroup.internalBinaryWrite(message.covers, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spotify.EpisodeShowMetadata
 */
export const EpisodeShowMetadata = new EpisodeShowMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EpisodeMetadata$Type extends MessageType<EpisodeMetadata> {
    constructor() {
        super("spotify.EpisodeMetadata", [
            { no: 1, name: "show", kind: "message", T: () => EpisodeShowMetadata },
            { no: 2, name: "link", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "length", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "covers", kind: "message", T: () => ImageGroup },
            { no: 6, name: "manifest_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "description", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "publish_date", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "freeze_frames", kind: "message", T: () => ImageGroup },
            { no: 10, name: "language", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "available", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "media_type_enum", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 13, name: "number", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "backgroundable", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "preview_manifest_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "is_explicit", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<EpisodeMetadata>): EpisodeMetadata {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EpisodeMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EpisodeMetadata): EpisodeMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional spotify.EpisodeShowMetadata show */ 1:
                    message.show = EpisodeShowMetadata.internalBinaryRead(reader, reader.uint32(), options, message.show);
                    break;
                case /* optional string link */ 2:
                    message.link = reader.string();
                    break;
                case /* optional string name */ 3:
                    message.name = reader.string();
                    break;
                case /* optional uint32 length */ 4:
                    message.length = reader.uint32();
                    break;
                case /* optional spotify.ImageGroup covers */ 5:
                    message.covers = ImageGroup.internalBinaryRead(reader, reader.uint32(), options, message.covers);
                    break;
                case /* optional string manifest_id */ 6:
                    message.manifestId = reader.string();
                    break;
                case /* optional string description */ 7:
                    message.description = reader.string();
                    break;
                case /* optional int64 publish_date */ 8:
                    message.publishDate = reader.int64().toBigInt();
                    break;
                case /* optional spotify.ImageGroup freeze_frames */ 9:
                    message.freezeFrames = ImageGroup.internalBinaryRead(reader, reader.uint32(), options, message.freezeFrames);
                    break;
                case /* optional string language */ 10:
                    message.language = reader.string();
                    break;
                case /* optional bool available */ 11:
                    message.available = reader.bool();
                    break;
                case /* optional int32 media_type_enum */ 12:
                    message.mediaTypeEnum = reader.int32();
                    break;
                case /* optional int32 number */ 13:
                    message.number = reader.int32();
                    break;
                case /* optional bool backgroundable */ 14:
                    message.backgroundable = reader.bool();
                    break;
                case /* optional string preview_manifest_id */ 15:
                    message.previewManifestId = reader.string();
                    break;
                case /* optional bool is_explicit */ 16:
                    message.isExplicit = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EpisodeMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional spotify.EpisodeShowMetadata show = 1; */
        if (message.show)
            EpisodeShowMetadata.internalBinaryWrite(message.show, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional string link = 2; */
        if (message.link !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.link);
        /* optional string name = 3; */
        if (message.name !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* optional uint32 length = 4; */
        if (message.length !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.length);
        /* optional spotify.ImageGroup covers = 5; */
        if (message.covers)
            ImageGroup.internalBinaryWrite(message.covers, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional string manifest_id = 6; */
        if (message.manifestId !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.manifestId);
        /* optional string description = 7; */
        if (message.description !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.description);
        /* optional int64 publish_date = 8; */
        if (message.publishDate !== undefined)
            writer.tag(8, WireType.Varint).int64(message.publishDate);
        /* optional spotify.ImageGroup freeze_frames = 9; */
        if (message.freezeFrames)
            ImageGroup.internalBinaryWrite(message.freezeFrames, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* optional string language = 10; */
        if (message.language !== undefined)
            writer.tag(10, WireType.LengthDelimited).string(message.language);
        /* optional bool available = 11; */
        if (message.available !== undefined)
            writer.tag(11, WireType.Varint).bool(message.available);
        /* optional int32 media_type_enum = 12; */
        if (message.mediaTypeEnum !== undefined)
            writer.tag(12, WireType.Varint).int32(message.mediaTypeEnum);
        /* optional int32 number = 13; */
        if (message.number !== undefined)
            writer.tag(13, WireType.Varint).int32(message.number);
        /* optional bool backgroundable = 14; */
        if (message.backgroundable !== undefined)
            writer.tag(14, WireType.Varint).bool(message.backgroundable);
        /* optional string preview_manifest_id = 15; */
        if (message.previewManifestId !== undefined)
            writer.tag(15, WireType.LengthDelimited).string(message.previewManifestId);
        /* optional bool is_explicit = 16; */
        if (message.isExplicit !== undefined)
            writer.tag(16, WireType.Varint).bool(message.isExplicit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spotify.EpisodeMetadata
 */
export const EpisodeMetadata = new EpisodeMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EpisodeSyncState$Type extends MessageType<EpisodeSyncState> {
    constructor() {
        super("spotify.EpisodeSyncState", [
            { no: 1, name: "offline_state", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "sync_progress", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<EpisodeSyncState>): EpisodeSyncState {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EpisodeSyncState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EpisodeSyncState): EpisodeSyncState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string offline_state */ 1:
                    message.offlineState = reader.string();
                    break;
                case /* optional uint32 sync_progress */ 2:
                    message.syncProgress = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EpisodeSyncState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string offline_state = 1; */
        if (message.offlineState !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.offlineState);
        /* optional uint32 sync_progress = 2; */
        if (message.syncProgress !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.syncProgress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spotify.EpisodeSyncState
 */
export const EpisodeSyncState = new EpisodeSyncState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EpisodePlayState$Type extends MessageType<EpisodePlayState> {
    constructor() {
        super("spotify.EpisodePlayState", [
            { no: 1, name: "time_left", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "is_playable", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "is_played", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "last_played_at", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<EpisodePlayState>): EpisodePlayState {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EpisodePlayState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EpisodePlayState): EpisodePlayState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 time_left */ 1:
                    message.timeLeft = reader.uint32();
                    break;
                case /* optional bool is_playable */ 2:
                    message.isPlayable = reader.bool();
                    break;
                case /* optional bool is_played */ 3:
                    message.isPlayed = reader.bool();
                    break;
                case /* optional uint32 last_played_at */ 4:
                    message.lastPlayedAt = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EpisodePlayState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 time_left = 1; */
        if (message.timeLeft !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.timeLeft);
        /* optional bool is_playable = 2; */
        if (message.isPlayable !== undefined)
            writer.tag(2, WireType.Varint).bool(message.isPlayable);
        /* optional bool is_played = 3; */
        if (message.isPlayed !== undefined)
            writer.tag(3, WireType.Varint).bool(message.isPlayed);
        /* optional uint32 last_played_at = 4; */
        if (message.lastPlayedAt !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.lastPlayedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spotify.EpisodePlayState
 */
export const EpisodePlayState = new EpisodePlayState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EpisodeCollectionState$Type extends MessageType<EpisodeCollectionState> {
    constructor() {
        super("spotify.EpisodeCollectionState", [
            { no: 1, name: "is_in_collection", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "is_new", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "is_in_listen_later", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<EpisodeCollectionState>): EpisodeCollectionState {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EpisodeCollectionState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EpisodeCollectionState): EpisodeCollectionState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool is_in_collection */ 1:
                    message.isInCollection = reader.bool();
                    break;
                case /* optional bool is_new */ 2:
                    message.isNew = reader.bool();
                    break;
                case /* optional bool is_in_listen_later */ 3:
                    message.isInListenLater = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EpisodeCollectionState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool is_in_collection = 1; */
        if (message.isInCollection !== undefined)
            writer.tag(1, WireType.Varint).bool(message.isInCollection);
        /* optional bool is_new = 2; */
        if (message.isNew !== undefined)
            writer.tag(2, WireType.Varint).bool(message.isNew);
        /* optional bool is_in_listen_later = 3; */
        if (message.isInListenLater !== undefined)
            writer.tag(3, WireType.Varint).bool(message.isInListenLater);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spotify.EpisodeCollectionState
 */
export const EpisodeCollectionState = new EpisodeCollectionState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrackAlbumArtistMetadata$Type extends MessageType<TrackAlbumArtistMetadata> {
    constructor() {
        super("spotify.TrackAlbumArtistMetadata", [
            { no: 1, name: "link", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TrackAlbumArtistMetadata>): TrackAlbumArtistMetadata {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TrackAlbumArtistMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrackAlbumArtistMetadata): TrackAlbumArtistMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string link */ 1:
                    message.link = reader.string();
                    break;
                case /* optional string name */ 2:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrackAlbumArtistMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string link = 1; */
        if (message.link !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.link);
        /* optional string name = 2; */
        if (message.name !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spotify.TrackAlbumArtistMetadata
 */
export const TrackAlbumArtistMetadata = new TrackAlbumArtistMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrackAlbumMetadata$Type extends MessageType<TrackAlbumMetadata> {
    constructor() {
        super("spotify.TrackAlbumMetadata", [
            { no: 1, name: "artist", kind: "message", T: () => TrackAlbumArtistMetadata },
            { no: 2, name: "link", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "covers", kind: "message", T: () => ImageGroup }
        ]);
    }
    create(value?: PartialMessage<TrackAlbumMetadata>): TrackAlbumMetadata {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TrackAlbumMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrackAlbumMetadata): TrackAlbumMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional spotify.TrackAlbumArtistMetadata artist */ 1:
                    message.artist = TrackAlbumArtistMetadata.internalBinaryRead(reader, reader.uint32(), options, message.artist);
                    break;
                case /* optional string link */ 2:
                    message.link = reader.string();
                    break;
                case /* optional string name */ 3:
                    message.name = reader.string();
                    break;
                case /* optional spotify.ImageGroup covers */ 4:
                    message.covers = ImageGroup.internalBinaryRead(reader, reader.uint32(), options, message.covers);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrackAlbumMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional spotify.TrackAlbumArtistMetadata artist = 1; */
        if (message.artist)
            TrackAlbumArtistMetadata.internalBinaryWrite(message.artist, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional string link = 2; */
        if (message.link !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.link);
        /* optional string name = 3; */
        if (message.name !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* optional spotify.ImageGroup covers = 4; */
        if (message.covers)
            ImageGroup.internalBinaryWrite(message.covers, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spotify.TrackAlbumMetadata
 */
export const TrackAlbumMetadata = new TrackAlbumMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrackArtistMetadata$Type extends MessageType<TrackArtistMetadata> {
    constructor() {
        super("spotify.TrackArtistMetadata", [
            { no: 1, name: "link", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TrackArtistMetadata>): TrackArtistMetadata {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TrackArtistMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrackArtistMetadata): TrackArtistMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string link */ 1:
                    message.link = reader.string();
                    break;
                case /* optional string name */ 2:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrackArtistMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string link = 1; */
        if (message.link !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.link);
        /* optional string name = 2; */
        if (message.name !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spotify.TrackArtistMetadata
 */
export const TrackArtistMetadata = new TrackArtistMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrackMetadata$Type extends MessageType<TrackMetadata> {
    constructor() {
        super("spotify.TrackMetadata", [
            { no: 1, name: "album", kind: "message", T: () => TrackAlbumMetadata },
            { no: 2, name: "artist", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TrackArtistMetadata },
            { no: 3, name: "link", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "length", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "playable", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "disc_number", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "track_number", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "is_explicit", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "preview_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "is_local", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "playable_local_track", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "has_lyrics", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "is_premium_only", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "locally_playable", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 16, name: "playable_track_link", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "popularity", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<TrackMetadata>): TrackMetadata {
        const message = { artist: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TrackMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrackMetadata): TrackMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional spotify.TrackAlbumMetadata album */ 1:
                    message.album = TrackAlbumMetadata.internalBinaryRead(reader, reader.uint32(), options, message.album);
                    break;
                case /* repeated spotify.TrackArtistMetadata artist */ 2:
                    message.artist.push(TrackArtistMetadata.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional string link */ 3:
                    message.link = reader.string();
                    break;
                case /* optional string name */ 4:
                    message.name = reader.string();
                    break;
                case /* optional uint32 length */ 5:
                    message.length = reader.uint32();
                    break;
                case /* optional bool playable */ 6:
                    message.playable = reader.bool();
                    break;
                case /* optional uint32 disc_number */ 7:
                    message.discNumber = reader.uint32();
                    break;
                case /* optional uint32 track_number */ 8:
                    message.trackNumber = reader.uint32();
                    break;
                case /* optional bool is_explicit */ 9:
                    message.isExplicit = reader.bool();
                    break;
                case /* optional string preview_id */ 10:
                    message.previewId = reader.string();
                    break;
                case /* optional bool is_local */ 11:
                    message.isLocal = reader.bool();
                    break;
                case /* optional bool playable_local_track */ 12:
                    message.playableLocalTrack = reader.bool();
                    break;
                case /* optional bool has_lyrics */ 13:
                    message.hasLyrics = reader.bool();
                    break;
                case /* optional bool is_premium_only */ 14:
                    message.isPremiumOnly = reader.bool();
                    break;
                case /* optional bool locally_playable */ 15:
                    message.locallyPlayable = reader.bool();
                    break;
                case /* optional string playable_track_link */ 16:
                    message.playableTrackLink = reader.string();
                    break;
                case /* optional uint32 popularity */ 17:
                    message.popularity = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrackMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional spotify.TrackAlbumMetadata album = 1; */
        if (message.album)
            TrackAlbumMetadata.internalBinaryWrite(message.album, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated spotify.TrackArtistMetadata artist = 2; */
        for (let i = 0; i < message.artist.length; i++)
            TrackArtistMetadata.internalBinaryWrite(message.artist[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional string link = 3; */
        if (message.link !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.link);
        /* optional string name = 4; */
        if (message.name !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.name);
        /* optional uint32 length = 5; */
        if (message.length !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.length);
        /* optional bool playable = 6; */
        if (message.playable !== undefined)
            writer.tag(6, WireType.Varint).bool(message.playable);
        /* optional uint32 disc_number = 7; */
        if (message.discNumber !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.discNumber);
        /* optional uint32 track_number = 8; */
        if (message.trackNumber !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.trackNumber);
        /* optional bool is_explicit = 9; */
        if (message.isExplicit !== undefined)
            writer.tag(9, WireType.Varint).bool(message.isExplicit);
        /* optional string preview_id = 10; */
        if (message.previewId !== undefined)
            writer.tag(10, WireType.LengthDelimited).string(message.previewId);
        /* optional bool is_local = 11; */
        if (message.isLocal !== undefined)
            writer.tag(11, WireType.Varint).bool(message.isLocal);
        /* optional bool playable_local_track = 12; */
        if (message.playableLocalTrack !== undefined)
            writer.tag(12, WireType.Varint).bool(message.playableLocalTrack);
        /* optional bool has_lyrics = 13; */
        if (message.hasLyrics !== undefined)
            writer.tag(13, WireType.Varint).bool(message.hasLyrics);
        /* optional bool is_premium_only = 14; */
        if (message.isPremiumOnly !== undefined)
            writer.tag(14, WireType.Varint).bool(message.isPremiumOnly);
        /* optional bool locally_playable = 15; */
        if (message.locallyPlayable !== undefined)
            writer.tag(15, WireType.Varint).bool(message.locallyPlayable);
        /* optional string playable_track_link = 16; */
        if (message.playableTrackLink !== undefined)
            writer.tag(16, WireType.LengthDelimited).string(message.playableTrackLink);
        /* optional uint32 popularity = 17; */
        if (message.popularity !== undefined)
            writer.tag(17, WireType.Varint).uint32(message.popularity);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spotify.TrackMetadata
 */
export const TrackMetadata = new TrackMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImageGroup$Type extends MessageType<ImageGroup> {
    constructor() {
        super("spotify.ImageGroup", [
            { no: 1, name: "standard_link", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "small_link", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "large_link", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "xlarge_link", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ImageGroup>): ImageGroup {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ImageGroup>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ImageGroup): ImageGroup {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string standard_link */ 1:
                    message.standardLink = reader.string();
                    break;
                case /* optional string small_link */ 2:
                    message.smallLink = reader.string();
                    break;
                case /* optional string large_link */ 3:
                    message.largeLink = reader.string();
                    break;
                case /* optional string xlarge_link */ 4:
                    message.xlargeLink = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ImageGroup, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string standard_link = 1; */
        if (message.standardLink !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.standardLink);
        /* optional string small_link = 2; */
        if (message.smallLink !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.smallLink);
        /* optional string large_link = 3; */
        if (message.largeLink !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.largeLink);
        /* optional string xlarge_link = 4; */
        if (message.xlargeLink !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.xlargeLink);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spotify.ImageGroup
 */
export const ImageGroup = new ImageGroup$Type();
// @generated message type with reflection information, may provide speed optimized methods
class User$Type extends MessageType<User> {
    constructor() {
        super("spotify.User", [
            { no: 1, name: "link", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "username", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "display_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "image_uri", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "thumbnail_uri", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<User>): User {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<User>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: User): User {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string link */ 1:
                    message.link = reader.string();
                    break;
                case /* optional string username */ 2:
                    message.username = reader.string();
                    break;
                case /* optional string display_name */ 3:
                    message.displayName = reader.string();
                    break;
                case /* optional string image_uri */ 4:
                    message.imageUri = reader.string();
                    break;
                case /* optional string thumbnail_uri */ 5:
                    message.thumbnailUri = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: User, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string link = 1; */
        if (message.link !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.link);
        /* optional string username = 2; */
        if (message.username !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.username);
        /* optional string display_name = 3; */
        if (message.displayName !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.displayName);
        /* optional string image_uri = 4; */
        if (message.imageUri !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.imageUri);
        /* optional string thumbnail_uri = 5; */
        if (message.thumbnailUri !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.thumbnailUri);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spotify.User
 */
export const User = new User$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Item$Type extends MessageType<Item> {
    constructor() {
        super("spotify.Item", [
            { no: 1, name: "header_field", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "add_time", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "added_by", kind: "message", T: () => User },
            { no: 4, name: "track_metadata", kind: "message", T: () => TrackMetadata },
            { no: 5, name: "track_collection_state", kind: "message", T: () => TrackCollectionState },
            { no: 6, name: "track_offline_state", kind: "message", T: () => TrackOfflineState },
            { no: 7, name: "row_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "track_play_state", kind: "message", T: () => TrackPlayState },
            { no: 9, name: "format_list_attributes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FormatListAttribute },
            { no: 10, name: "episode_metadata", kind: "message", T: () => EpisodeMetadata },
            { no: 11, name: "episode_offline_state", kind: "message", T: () => EpisodeSyncState },
            { no: 12, name: "episode_collection_state", kind: "message", T: () => EpisodeCollectionState },
            { no: 13, name: "episode_play_state", kind: "message", T: () => EpisodePlayState },
            { no: 14, name: "display_covers", kind: "message", T: () => ImageGroup }
        ]);
    }
    create(value?: PartialMessage<Item>): Item {
        const message = { formatListAttributes: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Item>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Item): Item {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string header_field */ 1:
                    message.headerField = reader.string();
                    break;
                case /* optional uint32 add_time */ 2:
                    message.addTime = reader.uint32();
                    break;
                case /* optional spotify.User added_by */ 3:
                    message.addedBy = User.internalBinaryRead(reader, reader.uint32(), options, message.addedBy);
                    break;
                case /* optional spotify.TrackMetadata track_metadata */ 4:
                    message.trackMetadata = TrackMetadata.internalBinaryRead(reader, reader.uint32(), options, message.trackMetadata);
                    break;
                case /* optional spotify.TrackCollectionState track_collection_state */ 5:
                    message.trackCollectionState = TrackCollectionState.internalBinaryRead(reader, reader.uint32(), options, message.trackCollectionState);
                    break;
                case /* optional spotify.TrackOfflineState track_offline_state */ 6:
                    message.trackOfflineState = TrackOfflineState.internalBinaryRead(reader, reader.uint32(), options, message.trackOfflineState);
                    break;
                case /* optional string row_id */ 7:
                    message.rowId = reader.string();
                    break;
                case /* optional spotify.TrackPlayState track_play_state */ 8:
                    message.trackPlayState = TrackPlayState.internalBinaryRead(reader, reader.uint32(), options, message.trackPlayState);
                    break;
                case /* repeated spotify.FormatListAttribute format_list_attributes */ 9:
                    message.formatListAttributes.push(FormatListAttribute.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional spotify.EpisodeMetadata episode_metadata */ 10:
                    message.episodeMetadata = EpisodeMetadata.internalBinaryRead(reader, reader.uint32(), options, message.episodeMetadata);
                    break;
                case /* optional spotify.EpisodeSyncState episode_offline_state */ 11:
                    message.episodeOfflineState = EpisodeSyncState.internalBinaryRead(reader, reader.uint32(), options, message.episodeOfflineState);
                    break;
                case /* optional spotify.EpisodeCollectionState episode_collection_state */ 12:
                    message.episodeCollectionState = EpisodeCollectionState.internalBinaryRead(reader, reader.uint32(), options, message.episodeCollectionState);
                    break;
                case /* optional spotify.EpisodePlayState episode_play_state */ 13:
                    message.episodePlayState = EpisodePlayState.internalBinaryRead(reader, reader.uint32(), options, message.episodePlayState);
                    break;
                case /* optional spotify.ImageGroup display_covers */ 14:
                    message.displayCovers = ImageGroup.internalBinaryRead(reader, reader.uint32(), options, message.displayCovers);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Item, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string header_field = 1; */
        if (message.headerField !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.headerField);
        /* optional uint32 add_time = 2; */
        if (message.addTime !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.addTime);
        /* optional spotify.User added_by = 3; */
        if (message.addedBy)
            User.internalBinaryWrite(message.addedBy, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional spotify.TrackMetadata track_metadata = 4; */
        if (message.trackMetadata)
            TrackMetadata.internalBinaryWrite(message.trackMetadata, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional spotify.TrackCollectionState track_collection_state = 5; */
        if (message.trackCollectionState)
            TrackCollectionState.internalBinaryWrite(message.trackCollectionState, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional spotify.TrackOfflineState track_offline_state = 6; */
        if (message.trackOfflineState)
            TrackOfflineState.internalBinaryWrite(message.trackOfflineState, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* optional string row_id = 7; */
        if (message.rowId !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.rowId);
        /* optional spotify.TrackPlayState track_play_state = 8; */
        if (message.trackPlayState)
            TrackPlayState.internalBinaryWrite(message.trackPlayState, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* repeated spotify.FormatListAttribute format_list_attributes = 9; */
        for (let i = 0; i < message.formatListAttributes.length; i++)
            FormatListAttribute.internalBinaryWrite(message.formatListAttributes[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* optional spotify.EpisodeMetadata episode_metadata = 10; */
        if (message.episodeMetadata)
            EpisodeMetadata.internalBinaryWrite(message.episodeMetadata, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* optional spotify.EpisodeSyncState episode_offline_state = 11; */
        if (message.episodeOfflineState)
            EpisodeSyncState.internalBinaryWrite(message.episodeOfflineState, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* optional spotify.EpisodeCollectionState episode_collection_state = 12; */
        if (message.episodeCollectionState)
            EpisodeCollectionState.internalBinaryWrite(message.episodeCollectionState, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* optional spotify.EpisodePlayState episode_play_state = 13; */
        if (message.episodePlayState)
            EpisodePlayState.internalBinaryWrite(message.episodePlayState, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* optional spotify.ImageGroup display_covers = 14; */
        if (message.displayCovers)
            ImageGroup.internalBinaryWrite(message.displayCovers, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spotify.Item
 */
export const Item = new Item$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Playlist$Type extends MessageType<Playlist> {
    constructor() {
        super("spotify.Playlist", [
            { no: 1, name: "playlist_metadata", kind: "message", T: () => PlaylistMetadata },
            { no: 2, name: "playlist_offline_state", kind: "message", T: () => PlaylistOfflineState }
        ]);
    }
    create(value?: PartialMessage<Playlist>): Playlist {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Playlist>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Playlist): Playlist {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional spotify.PlaylistMetadata playlist_metadata */ 1:
                    message.playlistMetadata = PlaylistMetadata.internalBinaryRead(reader, reader.uint32(), options, message.playlistMetadata);
                    break;
                case /* optional spotify.PlaylistOfflineState playlist_offline_state */ 2:
                    message.playlistOfflineState = PlaylistOfflineState.internalBinaryRead(reader, reader.uint32(), options, message.playlistOfflineState);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Playlist, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional spotify.PlaylistMetadata playlist_metadata = 1; */
        if (message.playlistMetadata)
            PlaylistMetadata.internalBinaryWrite(message.playlistMetadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional spotify.PlaylistOfflineState playlist_offline_state = 2; */
        if (message.playlistOfflineState)
            PlaylistOfflineState.internalBinaryWrite(message.playlistOfflineState, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spotify.Playlist
 */
export const Playlist = new Playlist$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RecommendationItem$Type extends MessageType<RecommendationItem> {
    constructor() {
        super("spotify.RecommendationItem", [
            { no: 1, name: "track_metadata", kind: "message", T: () => TrackMetadata },
            { no: 2, name: "track_collection_state", kind: "message", T: () => TrackCollectionState }
        ]);
    }
    create(value?: PartialMessage<RecommendationItem>): RecommendationItem {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RecommendationItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RecommendationItem): RecommendationItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional spotify.TrackMetadata track_metadata */ 1:
                    message.trackMetadata = TrackMetadata.internalBinaryRead(reader, reader.uint32(), options, message.trackMetadata);
                    break;
                case /* optional spotify.TrackCollectionState track_collection_state */ 2:
                    message.trackCollectionState = TrackCollectionState.internalBinaryRead(reader, reader.uint32(), options, message.trackCollectionState);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RecommendationItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional spotify.TrackMetadata track_metadata = 1; */
        if (message.trackMetadata)
            TrackMetadata.internalBinaryWrite(message.trackMetadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional spotify.TrackCollectionState track_collection_state = 2; */
        if (message.trackCollectionState)
            TrackCollectionState.internalBinaryWrite(message.trackCollectionState, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spotify.RecommendationItem
 */
export const RecommendationItem = new RecommendationItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Response$Type extends MessageType<Response> {
    constructor() {
        super("spotify.Response", [
            { no: 1, name: "item", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Item },
            { no: 2, name: "playlist", kind: "message", T: () => Playlist },
            { no: 3, name: "unfiltered_length", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "unranged_length", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "duration", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "loading_contents", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "last_modification", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "num_followers", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "playable", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "recommendations", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RecommendationItem },
            { no: 11, name: "has_explicit_content", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "contains_spotify_tracks", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "contains_episodes", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Response>): Response {
        const message = { item: [], recommendations: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Response): Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated spotify.Item item */ 1:
                    message.item.push(Item.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional spotify.Playlist playlist */ 2:
                    message.playlist = Playlist.internalBinaryRead(reader, reader.uint32(), options, message.playlist);
                    break;
                case /* optional uint32 unfiltered_length */ 3:
                    message.unfilteredLength = reader.uint32();
                    break;
                case /* optional uint32 unranged_length */ 4:
                    message.unrangedLength = reader.uint32();
                    break;
                case /* optional uint64 duration */ 5:
                    message.duration = reader.uint64().toBigInt();
                    break;
                case /* optional bool loading_contents */ 6:
                    message.loadingContents = reader.bool();
                    break;
                case /* optional uint64 last_modification */ 7:
                    message.lastModification = reader.uint64().toBigInt();
                    break;
                case /* optional uint32 num_followers */ 8:
                    message.numFollowers = reader.uint32();
                    break;
                case /* optional bool playable */ 9:
                    message.playable = reader.bool();
                    break;
                case /* repeated spotify.RecommendationItem recommendations */ 10:
                    message.recommendations.push(RecommendationItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool has_explicit_content */ 11:
                    message.hasExplicitContent = reader.bool();
                    break;
                case /* optional bool contains_spotify_tracks */ 12:
                    message.containsSpotifyTracks = reader.bool();
                    break;
                case /* optional bool contains_episodes */ 13:
                    message.containsEpisodes = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated spotify.Item item = 1; */
        for (let i = 0; i < message.item.length; i++)
            Item.internalBinaryWrite(message.item[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional spotify.Playlist playlist = 2; */
        if (message.playlist)
            Playlist.internalBinaryWrite(message.playlist, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 unfiltered_length = 3; */
        if (message.unfilteredLength !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.unfilteredLength);
        /* optional uint32 unranged_length = 4; */
        if (message.unrangedLength !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.unrangedLength);
        /* optional uint64 duration = 5; */
        if (message.duration !== undefined)
            writer.tag(5, WireType.Varint).uint64(message.duration);
        /* optional bool loading_contents = 6; */
        if (message.loadingContents !== undefined)
            writer.tag(6, WireType.Varint).bool(message.loadingContents);
        /* optional uint64 last_modification = 7; */
        if (message.lastModification !== undefined)
            writer.tag(7, WireType.Varint).uint64(message.lastModification);
        /* optional uint32 num_followers = 8; */
        if (message.numFollowers !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.numFollowers);
        /* optional bool playable = 9; */
        if (message.playable !== undefined)
            writer.tag(9, WireType.Varint).bool(message.playable);
        /* repeated spotify.RecommendationItem recommendations = 10; */
        for (let i = 0; i < message.recommendations.length; i++)
            RecommendationItem.internalBinaryWrite(message.recommendations[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* optional bool has_explicit_content = 11; */
        if (message.hasExplicitContent !== undefined)
            writer.tag(11, WireType.Varint).bool(message.hasExplicitContent);
        /* optional bool contains_spotify_tracks = 12; */
        if (message.containsSpotifyTracks !== undefined)
            writer.tag(12, WireType.Varint).bool(message.containsSpotifyTracks);
        /* optional bool contains_episodes = 13; */
        if (message.containsEpisodes !== undefined)
            writer.tag(13, WireType.Varint).bool(message.containsEpisodes);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spotify.Response
 */
export const Response = new Response$Type();
